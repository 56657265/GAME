<!doctype html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>테트리스 — 부드러운 움직임 + 유예시간 조정</title>
    <style>
  :root {
    --bg: #0b1a16;
    --panel: #07131a;
    --accent: #e6f0f4;
    --cell: 28;
  }

  html, body {
    height: 100%;
    margin: 0;
    background: linear-gradient(180deg, #0b1a16 0%, #04201a 100%);
    font-family: Inter, Segoe UI, Roboto, Apple SD Gothic Neo, Arial;
    color: var(--accent);
    -webkit-font-smoothing: antialiased;
  }

  .wrap {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 34px;
    padding: 28px;
    box-sizing: border-box;
  }

  .left,
  .right {
    width: 220px;
    flex: 0 0 220px;
  }

  .center {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .panel {
    background: rgba(0, 0, 0, 0.55);
    border: 2px solid rgba(255, 255, 255, 0.06);
    padding: 10px;
    border-radius: 8px;
  }

  .holdBox {
    height: 120px;
    width: 180px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 4px solid #fff6;
    border-radius: 6px;
    margin-bottom: 10px;
  }

  .nextStack {
    height: 480px;
    width: 180px;
    border: 4px solid #fff6;
    border-radius: 6px;
    padding: 6px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
    justify-content: flex-start;
  }

  .hud {
    margin-top: 12px;
    display: flex;
    gap: 18px;
    align-items: flex-end;
  }

  .stat {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    font-size: 18px;
    color: #d9eef6;
  }

  .stat small {
    opacity: 0.7;
    font-size: 12px;
  }

  canvas#board {
    background: #07141a;
    border-radius: 6px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
    border: 4px solid rgba(255, 255, 255, 0.06);
  }

  .controls {
    margin-top: 12px;
    font-size: 13px;
    opacity: 0.9;
  }

  .footer {
    position: fixed;
    left: 20px;
    bottom: 14px;
    opacity: 0.65;
    font-size: 12px;
  }

  @media (max-width: 900px) {
    .left,
    .right {
      display: none;
    }
    .wrap {
      padding: 10px;
    }
  }
   </style>
</head>

  <body>
    <div class="wrap">
      <div class="left">
        <div class="panel" style="margin-bottom:12px">
          <div style="font-weight:700;margin-bottom:8px">HOLD</div>
          <div class="holdBox panel" id="holdBox"><canvas id="hold" width="160" height="96"></canvas></div>
        </div>
        <div class="panel controls">
          <div style="font-weight:700;margin-bottom:6px">Controls</div>
          <div>← → : 좌우 이동</div>
          <div>↓ : 소프트 드롭</div>
          <div>Space : 하드 드롭</div>
          <div>↑ / X : 시계 회전</div>
          <div>Ctrl / Z : 반시계 회전</div>
          <div>Shift / C : 홀드</div>
          <div>A : 180도 회전</div>
        </div>
      </div>

      <div class="center">
        <canvas id="board" width="280" height="560"></canvas>
        <div class="hud">
	  <div class="stat"><small>Time</small><div id="time">0.00</div></div>
	  <div class="stat"><small>Lines</small><div id="lines">0</div></div>
	</div>
      </div>

      <div class="right">
        <div class="panel" style="margin-bottom:12px">
          <div style="font-weight:700;margin-bottom:8px">NEXT</div>
          <div class="nextStack" id="nextStack">
            <canvas id="next0" width="160" height="64"></canvas>
            <canvas id="next1" width="160" height="64"></canvas>
            <canvas id="next2" width="160" height="64"></canvas>
            <canvas id="next3" width="160" height="64"></canvas>
            <canvas id="next4" width="160" height="64"></canvas>
          </div>
        </div>
        <div class="panel controls" style="margin-top:8px">
          <div>기본 유예: 1.05초로 고정된 lockdown</div>
          <div>소프트 드롭: 60ms / cell (≈16.67 cell/s)</div>
          <div>동시 키 입력 지원</div>
        </div>
      </div>
    </div>

    <div class="footer">Based on layout from 1.png / 2.png / 3.png (ads excluded)</div>

<script>
  const COLS = 10, ROWS = 20;
  const boardCanvas = document.getElementById('board');
  const ctx = boardCanvas.getContext('2d');
  const nextCtx = [...Array(5)].map((_, i) => document.getElementById(`next${i}`).getContext('2d'));
  const holdCtx = document.getElementById('hold').getContext('2d');
  const COLORS = { I:'#1abcff', O:'#ffd400', T:'#c47cff', S:'#2ecc71', Z:'#e74c3c', J:'#2b6cff', L:'#ff8c1a' };
  const SHAPES = {
    I:[[[0,1],[1,1],[2,1],[3,1]],[[2,0],[2,1],[2,2],[2,3]],[[0,2],[1,2],[2,2],[3,2]],[[1,0],[1,1],[1,2],[1,3]]],
    O:[[[1,0],[2,0],[1,1],[2,1]]],
    T:[[[1,0],[0,1],[1,1],[2,1]],[[1,0],[1,1],[2,1],[1,2]],[[0,1],[1,1],[2,1],[1,2]],[[1,0],[0,1],[1,1],[1,2]]],
    S:[[[1,0],[2,0],[0,1],[1,1]],[[1,0],[1,1],[2,1],[2,2]],[[1,1],[2,1],[0,2],[1,2]],[[0,0],[0,1],[1,1],[1,2]]],
    Z:[[[0,0],[1,0],[1,1],[2,1]],[[2,0],[1,1],[2,1],[1,2]],[[0,1],[1,1],[1,2],[2,2]],[[1,0],[0,1],[1,1],[0,2]]],
    J:[[[0,0],[0,1],[1,1],[2,1]],[[1,0],[2,0],[1,1],[1,2]],[[0,1],[1,1],[2,1],[2,2]],[[1,0],[1,1],[0,2],[1,2]]],
    L:[[[2,0],[0,1],[1,1],[2,1]],[[1,0],[1,1],[1,2],[2,2]],[[0,1],[1,1],[2,1],[0,2]],[[0,0],[1,0],[1,1],[1,2]]]
  };

	let board=[], bag=[], current=null, hold=null, holdUsed=false;
	let lines=0;
	let dropInterval=1000, softTimer=0, lockTimer=0, gravityTimer=0;
	const SOFT_DROP_INTERVAL=60, LOCK_DELAY_MS=1050;
	const DAS=160, ARR=40;

	let dasDir=0, dasTimer=0, arrTimer=0;
	let CELL=28;

	let startTime = null;   // 게임 시작 시간
	let gameOverFlag = false; // 20줄 달성 후 종료 플래그


  function resize(){
    CELL=Math.floor(Math.min(window.innerHeight*0.8,window.innerWidth*0.5)/ROWS);
    boardCanvas.width=COLS*CELL;
    boardCanvas.height=ROWS*CELL;
    const ns=document.getElementById('nextStack');
    if(ns) ns.style.gap=CELL+'px';
  }
  resize();
  window.addEventListener('resize',resize);

  function newBoard(){ board=Array.from({length:ROWS},()=>Array(COLS).fill(null)); }
  newBoard();

  function refillBag(){
    const types=Object.keys(SHAPES), arr=types.slice();
    for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];}
    bag.push(...arr);
  }

  function isValid(p,x,y,r){
    const shape=SHAPES[p.type][r%SHAPES[p.type].length];
    for(const [dx,dy] of shape){
      const nx=x+dx, ny=y+dy;
      if(nx<0||nx>=COLS||ny>=ROWS) return false;
      if(ny>=0 && board[ny][nx]) return false;
    }
    return true;
  }

  function drawHold(){
    holdCtx.clearRect(0,0,160,96);
    if(!hold) return;
    const shape=SHAPES[hold][0], color=COLORS[hold], cell=35;
    const offsetX=80-(Math.max(...shape.map(p=>p[0]))+1)*cell/2;
    const offsetY=48-(Math.max(...shape.map(p=>p[1]))+1)*cell/2;
    holdCtx.fillStyle=color;
    for(const [x,y] of shape) holdCtx.fillRect(offsetX+x*cell, offsetY+y*cell, cell-2, cell-2);
  }

  function drawNext(){
    const totalNext=5, canvasW=160, cell=CELL;
    for(let i=0;i<totalNext;i++){
      const canvas=document.getElementById(`next${i}`), ctx=nextCtx[i];
      ctx.clearRect(0,0,canvas.width||canvasW,canvas.height||cell);
      const type=bag[i];
      if(!type){ canvas.width=canvasW; canvas.height=cell; canvas.style.width=canvasW+'px'; canvas.style.height=canvas.height+'px'; continue; }
      const shape=SHAPES[type][0], color=COLORS[type];
      const xs=shape.map(p=>p[0]), ys=shape.map(p=>p[1]);
      const minX=Math.min(...xs), maxX=Math.max(...xs), minY=Math.min(...ys), maxY=Math.max(...ys);
      const w=maxX-minX+1, h=maxY-minY+1;
      canvas.width=canvasW; canvas.height=h*cell; canvas.style.width=canvasW+'px'; canvas.style.height=canvas.height+'px';
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle=color;
      const offsetX=(canvas.width-w*cell)/2, offsetY=0;
      for(const [x,y] of shape) ctx.fillRect(offsetX+(x-minX)*cell, offsetY+(y-minY)*cell, cell-2, cell-2);
    }
  }

  function spawn(){
    if(gameOverFlag) return;
    if(!startTime) startTime = performance.now(); // ⬅️ 게임 시작 시간 기록
    if(bag.length<7) refillBag();
    const type=bag.shift();
    current={type, rot:0, x:3, y:-1, px:3, py:-1};
    if(!isValid(current,current.x,current.y,current.rot)){
      alert('Game Over');
      newBoard(); score=lines=level=0; bag=[]; refillBag();
    }
    holdUsed=false; lockTimer=0; gravityTimer=0; softTimer=0;
    drawNext();
  }

  function lock(){
    if(!current) return;
    const s=SHAPES[current.type][current.rot];
    for(const [dx,dy] of s){
      const nx=current.x+dx, ny=current.y+dy;
      if(ny>=0) board[ny][nx]=current.type;
    }
    clearLines();
    spawn();
  }

function clearLines(){
  let c = 0;

  for(let r=ROWS-1;r>=0;r--){
    if(board[r].every(v=>v)){
      board.splice(r,1);
      board.unshift(Array(COLS).fill(null));
      c++;
      r++;
    }
  }

  if(c){
    lines += c;

    // 20줄 달성 → 종료
    if(lines >= 20 && !gameOverFlag){
      gameOverFlag = true;
      const endTime = performance.now();
      const timeTaken = ((endTime - startTime)/1000).toFixed(2);
      alert(`축하합니다! 20줄 달성!\n걸린 시간: ${timeTaken}초`);
    }
  }
}


  function move(dx){ if(isValid(current,current.x+dx,current.y,current.rot)){current.x+=dx;return true;} return false; }
  function soft(){
  if(isValid(current,current.x,current.y+1,current.rot)){
    current.y++;
    return true;
  }
  return false;
}

  function hard(){
  while(isValid(current,current.x,current.y+1,current.rot)){
    current.y++;
  }
  lock();
}

  function rotate(d){
    const len=SHAPES[current.type].length;
    const nr=(current.rot+d+len)%len;
    const kicks=[[0,0],[1,0],[-1,0],[0,-1]];
    for(const[kx,ky]of kicks){
      if(isValid(current,current.x+kx,current.y+ky,nr)){ current.rot=nr; current.x+=kx; current.y+=ky; return; }
    }
  }
  function holdSwap(){ if(holdUsed) return; if(!hold){hold=current.type;spawn();} else{[hold,current.type]=[current.type,hold]; current.rot=0; current.x=3; current.y=-1;} holdUsed=true; drawHold(); }

  const key={};
  addEventListener('keydown',e=>{
    if(['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' ','x','z','a','c','Shift','X','Z','A','C'].includes(e.key)) e.preventDefault();
    key[e.key]=true;
    if(e.key===' ') hard();
    else if(['ArrowUp','x','X'].includes(e.key)) rotate(1);
    else if(['z','Z'].includes(e.key)||e.ctrlKey) rotate(-1);
    else if(['a','A'].includes(e.key)) rotate(2);
    else if(['Shift','c','C'].includes(e.key)) holdSwap();
  });
  addEventListener('keyup',e=>key[e.key]=false);

  function drawCell(x,y,c){ ctx.fillStyle=c; ctx.fillRect(x*CELL+1,y*CELL+1,CELL-2,CELL-2); }
  function draw(){
    ctx.clearRect(0,0,boardCanvas.width,boardCanvas.height);
    ctx.fillStyle='#041314'; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(board[r][c]) drawCell(c,r,COLORS[board[r][c]]);
    if(current){
      const shape=SHAPES[current.type][current.rot];
      const lerp=(a,b,t)=>a+(b-a)*t; const t=0.3;
      current.px=lerp(current.px,current.x,t); current.py=lerp(current.py,current.y,t);
      for(const[dx,dy]of shape){ const x=current.px+dx, y=current.py+dy; if(y>=0) drawCell(x,y,COLORS[current.type]); }
      let gy=current.y; while(isValid(current,current.x,gy+1,current.rot)) gy++;
      ctx.globalAlpha=0.2;
      for(const[dx,dy]of shape){ const x=current.x+dx, y=gy+dy; if(y>=0) drawCell(x,y,COLORS[current.type]); }
      ctx.globalAlpha=1;
    }
document.getElementById('lines').textContent = lines;

if(startTime){
  const now = performance.now();
  const timeSec = ((now - startTime)/1000).toFixed(2);
  document.getElementById('time').textContent = timeSec;
}
    drawHold();
    drawNext();
  }

  let last=performance.now();
  function loop(now){
    if(gameOverFlag) return; // ⬅️ 게임 종료 시 루프 멈춤
    const dt=now-last; last=now; gravityTimer+=dt;
    if(gravityTimer>dropInterval){ gravityTimer-=dropInterval; if(isValid(current,current.x,current.y+1,current.rot)) current.y++; }
    if(key['ArrowDown']){ softTimer+=dt; while(softTimer>=SOFT_DROP_INTERVAL){ softTimer-=SOFT_DROP_INTERVAL; soft(); } } else { softTimer=0; }
    if(key['ArrowLeft']&&!key['ArrowRight']){
      if(dasDir!==-1){ dasDir=-1; dasTimer=0; arrTimer=0; move(-1); }
      else{ dasTimer+=dt; if(dasTimer>=DAS){ arrTimer+=dt; while(arrTimer>=ARR){ arrTimer-=ARR; move(-1); } } }
    } else if(key['ArrowRight']&&!key['ArrowLeft']){
      if(dasDir!==1){ dasDir=1; dasTimer=0; arrTimer=0; move(1); }
      else{ dasTimer+=dt; if(dasTimer>=DAS){ arrTimer+=dt; while(arrTimer>=ARR){ arrTimer-=ARR; move(1); } } }
    } else { dasDir=0; dasTimer=0; arrTimer=0; }
    const touching=!isValid(current,current.x,current.y+1,current.rot);
    if(touching){ lockTimer+=dt; if(lockTimer>=LOCK_DELAY_MS){ lockTimer=0; lock(); } } else { lockTimer=0; }
    draw();
    requestAnimationFrame(loop);
  }

  refillBag(); spawn(); requestAnimationFrame(loop);
    </script>
  </body>
</html>
